### 1. **DRY (Don't Repeat Yourself):**
   - Цей принцип рекомендує уникати дублювання коду. Шукайте можливості для рефакторингу повторюваного коду в перевикористовувані методи або класи.

   Приклад:
   - У класі `Reporting` методи `PrintArrivalReports()` та `PrintShipmentReports()` мають схожий код для друку звітів. Розгляньте можливість рефакторингу цього коду в один метод для уникнення дублювання.

### 2. **KISS (Keep It Simple, Stupid):**
   - Простота віддається перевага складності. Робіть код простим і зрозумілим.

   Приклад:
   - Метод `Print()` у класі `Money` дотримується принципу KISS, надаючи простий і зрозумілий спосіб виведення інформації про гроші.

### 3. **Принципи SOLID:**
   - **S**ingle Responsibility Principle: Кожен клас повинен мати одну і лише одну відповідальність.
   - **O**pen/Closed Principle: Класи повинні бути відкриті для розширення, але закриті для змін.
   - **L**iskov Substitution Principle: Об'єкти суперкласу повинні бути замінними об'єктами підкласу без впливу на функціональність.
   - **I**nterface Segregation Principle: Клієнти не повинні залежати від інтерфейсів, які вони не використовують.
   - **D**ependency Inversion Principle: Залежність від абстракцій, а не від конкретних реалізацій.

   Приклад:
   - Клас `Product` дотримується принципу Single Responsibility, оскільки керує лише ціною продукту.
   - Клас `Reporting` дотримується принципу Open/Closed, дозволяючи додавати нові типи звітів без модифікації існуючого коду.
   - Клас `Reporting` використовує інтерфейси для дотримання принципу Interface Segregation, забезпечуючи тим самим, що клієнти залежать лише від потрібних методів.

### 4. **YAGNI (You Ain't Gonna Need It):**
   - Уникайте реалізації функціональності, поки вона не є необхідною. Додавайте лише ті функції, які необхідні для поточних вимог, а не потенційних майбутніх.

   Приклад:
   - Клас `Money` фокусується на виведенні інформації про гроші, без зайвих додаткових функцій.

### 5. **Композиція над Наслідуванням:**
   - Віддавайте перевагу композиції (має-відношення) над наслідуванням (є-відношення), щоб досягти повторного використання коду.

   Приклад:
   - Клас `Reporting` містить списки звітів як композицію, що дозволяє йому керувати різними типами звітів без наслідування від різних класів звітів.

### 6. **Програмування до Інтерфейсів, а не Реалізацій:**
   - Залежіть від абстракцій (інтерфейсів), а не від конкретних реалізацій, щоб розрізнити компоненти і зробити код більш гнучким.

   Приклад:
   - Клас `Reporting` приймає об'єкти `Warehouse` у своїх методах, дотримуючись принципу Програмування до Інтерфейсів.

### 7. **Fail Fast:**
   - Виявляйте та реагуйте на помилки якнайшвидше, щоб запобігти каскадним відмовам і спростити налагодження.

   Приклад:
   - Перевірка введення виконується в головному циклі класу `Program` (блок try-catch навколо `int.TryParse()`), щоб гарантувати гарне